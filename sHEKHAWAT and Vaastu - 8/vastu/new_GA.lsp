; Final GA PROGRAM
(setq initial_population nil)
(setq initial_population(numberofchromosomes 300 8))
;(setq initial_population (List (List (List (List 5 4) (List 14 0 7) (List 9 3 8 13 10 2) (List 1 11) (List 15 6 12)) (List (List 15 12 4) (List 13 5 9 11) (List 6 0 10 3) (List 8 7 14) (List 1 2)) (List (List 13 2 14) (List 6 11 10) (List 0 1 4) (List 15 9 8) (List 7 12 3 5)) (List (List 1 10 11 6) (List 0 14 15) (List 5 9 12 13 2 8) (List 4 3)) (List (List 12 8 0) (List 14 15 3 6) (List 10 13 1 5 7 9 2) (List 4 11)) (List (List 14 11 2 4 5) (List 10 13 6 9) (List 3 12 8 1 0)) (List (List 11 7 9 3 4 10) (List 15 13) (List 8 0 12) (List 1 5 6 14)) (List (List 1 8 15 13 4 7) (List 0 11) (List 10 6 3 12 9) (List 5 2)) (List (List 3 13) (List 9 0 10 5) (List 7 15 11 2) (List 4 14 12 8 1)) (List (List 9 12) (List 4 2) (List 13 8 10 7) (List 11 6) (List 1 0 3 15 14 5))) (List (List (List 1 10) (List 3 5 11 7 14 13) (List 15 4 12 2) (List 6 0 8 9)) (List (List 12 1 10 9 14) (List 5 13) (List 3 2 8) (List 11 7 6 4 0 15)) (List (List 5 3 14 6 1) (List 11 7 8 4 9 10 13) (List 15 12) (List 0 2)) (List (List 12 8 0) (List 4 6) (List 14 15 3 13) (List 5 11 10 9 7) (List 1 2)) (List (List 10 12 14 9 4 15 8) (List 13 2 0) (List 11 3) (List 1 5) (List 6 7)) (List (List 12 10 15 5) (List 3 0 7) (List 11 6 1 4) (List 13 8 9) (List 2 14)) (List (List 11 3 4 2) (List 14 6 15 7) (List 9 0 10) (List 5 12 13) (List 8 1)) (List (List 0 8 7 13 5) (List 2 11 1) (List 4 14) (List 6 9 15) (List 3 10 12)) (List (List 8 4 15) (List 7 5 6) (List 1 13 2 3 12) (List 9 0 11 10)) (List (List 11 12) (List 7 14 6 3 2) (List 5 10 13 0) (List 8 1 9 4))) (List (List (List 10 13 0 7) (List 3 15 9 6 1 14 2) (List 5 4 8 11)) (List (List 11 15) (List 4 0 10) (List 8 7 1 9 12) (List 6 3 2 5 13)) (List (List 15 4 0 6 12) (List 9 3) (List 5 13 1) (List 2 14 8 10) (List 7 11)) (List (List 0 7 8 6 2 1) (List 4 3 15) (List 9 12 10 11) (List 14 13)) (List (List 3 12 10 6 5) (List 1 0) (List 2 14) (List 4 11 7 9 15) (List 13 8)) (List (List 12 0 14) (List 15 8) (List 13 5 4 1) (List 11 6 9 3 10) (List 2 7)) (List (List 13 4 15 12) (List 5 14) (List 6 3 9) (List 2 0 11 8 7) (List 1 10)) (List (List 12 9 6 4) (List 2 11 5 1 14) (List 13 15 10) (List 0 8 7)) (List (List 13 12 9) (List 0 3 7 5) (List 10 2) (List 11 15 8 6) (List 14 1 4)) (List (List 7 8 9) (List 5 0 3) (List 13 2 15) (List 10 12 6 4 11 14))) (List (List (List 4 5 6) (List 1 10 9) (List 15 0) (List 8 13 11 7) (List 2 14 3 12)) (List (List 13 10 5 6 9 14) (List 12 1 2 0) (List 15 11 3) (List 8 7)) (List (List 14 1 6) (List 8 5 3 7) (List 12 4 9) (List 15 2 11 10 0)) (List (List 2 10 9 1 7) (List 12 0 14) (List 11 3 8 13 4 6)) (List (List 8 14) (List 6 11 5) (List 7 9 4 12 15 0 13) (List 1 3) (List 2 10)) (List (List 10 12 11) (List 0 15 13 6) (List 5 7 4 14) (List 9 1 3) (List 8 2)) (List (List 12 1) (List 13 5 11 7) (List 4 2 3 15 8) (List 10 9 0) (List 6 14)) (List (List 9 4) (List 0 14 5 7) (List 2 11 8) (List 6 1 10) (List 15 13 12 3)) (List (List 13 6) (List 3 14 12) (List 1 7 15 8 11) (List 0 10 2) (List 9 4 5)) (List (List 14 2 3 10 5 4) (List 0 9 8 13 15) (List 1 11) (List 12 6 7))) (List (List (List 3 0 9) (List 2 7 11 6 15 8) (List 10 5 4) (List 14 12 1)) (List (List 13 5 6) (List 4 12 1 2) (List 3 9 15 11 14) (List 8 0) (List 10 7)) (List (List 2 4 6 12) (List 13 14 3) (List 15 5 10 9 8 1) (List 11 0)) (List (List 7 0 14 3 1) (List 10 9) (List 8 5 2 15 11) (List 6 13 4)) (List (List 2 5 9) (List 11 3 15 6) (List 4 1 10) (List 13 0 8 12 14)) (List (List 15 5) (List 2 8) (List 14 10 6 9 0 3) (List 13 11 7 4 1)) (List (List 10 6 1 15) (List 5 13 2) (List 11 3 0 8) (List 7 12 14 9)) (List (List 4 7 8 3 6) (List 11 12) (List 1 2 0 5 15 14) (List 9 13 10)) (List (List 3 1 15) (List 12 9 0) (List 2 13) (List 4 5 11 10) (List 14 6 8 7)) (List (List 14 6) (List 1 10 9) (List 7 5 2 13 12 8) (List 4 11 3 0))) (List (List (List 7 6 10 15) (List 3 5 9) (List 4 11 1 2) (List 12 0 13 14)) (List (List 14 6 11 4 13) (List 0 15) (List 5 8 9 3) (List 10 12 7 2)) (List (List 10 11 13) (List 5 14) (List 12 0 15) (List 4 3 9 2 8) (List 7 6 1)) (List (List 13 7 8 14) (List 2 5 15 1) (List 3 12) (List 6 11 4) (List 9 0 10)) (List (List 15 2 9 0 8 13) (List 14 11 5) (List 10 6 12 4 1)) (List (List 11 1) (List 3 5 7 6) (List 4 10 0 12 14 8 13 2) (List 9 15)) (List (List 2 11 14 6 4) (List 15 0 10 3 5) (List 13 12 7 9 1)) (List (List 15 9) (List 10 2 7 6) (List 3 8 14) (List 12 13 5 11 4) (List 1 0)) (List (List 9 15 13 7) (List 8 4 2 5 14) (List 1 0 10 12) (List 11 3 6)) (List (List 2 15) (List 1 9) (List 10 6 0) (List 14 8) (List 7 3 12 11 13 4 5))) (List (List (List 8 1 6) (List 0 14 11) (List 13 5 2 12) (List 9 3 15 7 10)) (List (List 4 0 9) (List 1 8 10 6) (List 15 5 14) (List 13 12 2 7 11)) (List (List 9 4) (List 12 10) (List 11 7 2 8 3 6) (List 1 0 14 13 5)) (List (List 5 15 14 9 12) (List 11 0) (List 4 1 3 8 7) (List 6 13 2)) (List (List 4 14 8) (List 13 7 0 1 9 11 3) (List 12 6) (List 5 10 2)) (List (List 9 13 3) (List 8 10 0 14) (List 11 5) (List 2 15 12) (List 4 6 7 1)) (List (List 3 13 11 7 6 0) (List 8 1 4) (List 14 10) (List 15 5) (List 2 12 9)) (List (List 10 11 8 2 3 1) (List 12 15) (List 7 5) (List 14 13 9) (List 6 0 4)) (List (List 7 0 14) (List 15 10 12 4) (List 2 6 5) (List 9 8 11) (List 13 1 3)) (List (List 4 6 2) (List 3 12 8 11 15 9 1) (List 7 10 5) (List 13 14))) (List (List (List 6 15) (List 0 9 7 11 12 14 5) (List 4 10 1 8) (List 13 2 3)) (List (List 9 7) (List 14 13 1) (List 4 0 2 6) (List 10 11 5) (List 3 12 15 8)) (List (List 15 0 5 9) (List 6 11 12 2 13 1) (List 3 14) (List 8 10) (List 4 7)) (List (List 8 14 9 11) (List 6 0) (List 15 5 2 10 13) (List 1 12 4 3 7)) (List (List 2 0 9 14 4 7 15) (List 8 1 13) (List 11 5) (List 10 6) (List 12 3)) (List (List 12 2 13 3 11) (List 15 5 1 7 9) (List 0 10) (List 14 8 4)) (List (List 15 2 13) (List 8 7 6 4 11 5) (List 1 9 0 10 12)) (List (List 2 13 14) (List 5 15 9) (List 11 8 1 12) (List 4 3 0 7 10)) (List (List 9 15) (List 14 11 1) (List 8 12 10 5 2) (List 0 13 4 7 3)) (List (List 10 8 5 9 15) (List 6 7 13 12 3) (List 1 14) (List 11 2 0))) (List (List (List 9 7 12) (List 8 1 10 6) (List 14 5 0 3) (List 11 4 2 15 13)) (List (List 9 12 8) (List 5 15 1 2 13) (List 7 3 10) (List 0 11 4 6)) (List (List 2 14 4) (List 3 1 13 9 12) (List 7 15 8) (List 5 0 6) (List 10 11)) (List (List 15 0 5) (List 7 12 11) (List 14 13 9) (List 1 6 8 4) (List 2 3 10)) (List (List 2 11) (List 8 9 15) (List 0 6 12) (List 1 10) (List 7 13 5 4 14 3)) (List (List 7 6) (List 0 14 1 15 10) (List 2 11 4 3) (List 13 5 8 9)) (List (List 8 4) (List 9 13 3 15) (List 2 0) (List 14 12 7 1 11 10) (List 6 5)) (List (List 15 6 3 12 14) (List 0 7 1 5 2) (List 10 13) (List 8 4 11)) (List (List 8 5 13 4) (List 14 10 15 9 3) (List 0 11 1) (List 12 2 6)) (List (List 15 6 3 5) (List 12 2) (List 11 1 0) (List 14 8 9 13 10 7))) (List (List (List 11 2 3 9 7) (List 14 1 13 6) (List 15 5 12) (List 4 10 8)) (List (List 0 6 7 12 1) (List 4 2) (List 3 14 15 8 5 9) (List 11 13)) (List (List 4 9) (List 15 8 0) (List 5 1 14 13 2) (List 11 7 10) (List 6 3 12)) (List (List 6 5 3 2 13) (List 12 10 1 0) (List 14 11) (List 8 15 9 7)) (List (List 8 14 12) (List 10 15 3 1 11) (List 13 0 9 4) (List 2 5 7 6)) (List (List 1 8 12 4 7) (List 14 10 11) (List 2 5) (List 0 3 9 13 6 15)) (List (List 12 11 3) (List 15 4 5 1 10 14 7 9 2) (List 0 13 8)) (List (List 9 3 2 8) (List 12 6 7) (List 5 10 11 13 0 14) (List 1 4)) (List (List 3 4) (List 0 5) (List 10 14 13) (List 6 12 15 1 11) (List 9 8 7 2)) (List (List 1 5) (List 8 3 13) (List 0 14 10 15) (List 7 2 9 11 12 4)))))
(setq population_length 10)

(defun unique ( l )
  (if l
    (cons (car l)
      (unique (vl-remove (car l) (cdr l)))
    )
  )
)

(defun newGA()
         (setq best_population nil)
         (setq fitness_pop nil)
         (setq no_ele 10)
  	(setq final_population nil)
	(setq fitness_population0 nil)
  (setq fitness_population1 nil)
(setq fitness_population2 nil)
(setq fitness_population3 nil)
(setq fitness_population4 nil)
(setq fitness_population5 nil)
(setq fitness_population6 nil)
(setq fitness_population7 nil)
(setq fitness_population8 nil)
(setq fitness_population9 nil)
(setq mating_iter 20)
  	(setq new_population nil)
	(setq maximum_iterations 25)
	(setq average_fitness nil)
	(setq crossover_probability 0.95)
	(setq mutation_probability 0.05)
  (setq chanceit 8)
    
      
	     (setq output0 nil)
  (setq output1 nil)
(setq output2 nil)
(setq output3 nil)
(setq output4 nil)
(setq output5 nil)
(setq output6 nil)
(setq output7 nil)
(setq output8 nil)
(setq output9 nil)
  

  	(setq final_population initial_population)
               

    (princ "Initial_pop ok with length") (princ (length final_population)) (princ "\n")
  
	     (setq output0 (append output0 (nth 0 final_population)))
	   
	     (setq output1 (append output1 (nth 1 final_population)))
	   
	     (setq output2 (append output2(nth 2 final_population)))
	    
	     (setq output3 (append output3 (nth 3 final_population)))
	   
	     (setq output4 (append output4 (nth 4 final_population)))
	    
	     (setq output5(append output5 (nth 5 final_population)))
	     
	     (setq output6(append output6 (nth  6 final_population)))
	     
	     (setq output7 (append output7 (nth 7 final_population)))
	     
	     (setq output8 (append output8 (nth 8 final_population)))
	     
	     (setq output9 (append output9 (nth 9 final_population)))
	      
           ; (princ (length output0))
  
	   ;  (princ output1)(princ "\n")
	    ; (princ output2)(princ "\n")
             ;(princ output3)(princ "\n")
	     ;(princ output4)(princ "\n")
	     ;(princ output5)(princ "\n")
	     ;(princ output6)(princ "\n")
	     ;(princ output7)(princ "\n")
	     ;(princ output8)(princ "\n")
	      ;(princ output9)
  

  	(setq sum0 0)
  (setq sum1 0)
(setq sum2 0)
(setq sum3 0)
(setq sum4 0)
(setq sum5 0)
(setq sum6 0)
(setq sum7 0)
(setq sum8 0)
(setq sum9 0)

;(setq chromosome nil)
    ;(setq count 0)
  	(foreach chromosome0 output0
	  	(setq value0 (fitness_function chromosome0))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population0 (append fitness_population0 (list value0)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum0 (+ sum0 value0))
	  )
    (setq elit nil)
    (setq elit (selectTopElements output0 fitness_population0 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome1 output1
	  	(setq value1 (fitness_function chromosome1))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population1 (append fitness_population1 (list value1)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum1 (+ sum1 value1))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output1 fitness_population1 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome2 output2
	  	(setq value2 (fitness_function chromosome2))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population2 (append fitness_population2 (list value2)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum2 (+ sum2 value2))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output2 fitness_population2 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome3 output3
	  	(setq value3 (fitness_function chromosome3))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population3 (append fitness_population3 (list value3)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum3 (+ sum3 value3))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output3 fitness_population3 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome4 output4
	  	(setq value4 (fitness_function chromosome4))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population4 (append fitness_population4 (list value4)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum4 (+ sum4 value4))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output4 fitness_population4 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome5 output5
	  	(setq value5 (fitness_function chromosome5))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population5 (append fitness_population5 (list value5)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum5 (+ sum5 value5))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output5 fitness_population5 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome6 output6
	  	(setq value6 (fitness_function chromosome6))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population6 (append fitness_population6 (list value6)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum6 (+ sum6 value6))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output6 fitness_population6 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome7 output7
	  	(setq value7 (fitness_function chromosome7))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population7 (append fitness_population7 (list value7)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum7 (+ sum7 value7))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output7 fitness_population7 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome8 output8
	  	(setq value8 (fitness_function chromosome8))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population8 (append fitness_population8 (list value8)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum8 (+ sum8 value8))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output8 fitness_population8 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	(foreach chromosome9 output9
	  	(setq value9 (fitness_function chromosome9))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population9 (append fitness_population9 (list value9)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum9 (+ sum9 value9))
	  )
  (setq elit nil)
    (setq elit (selectTopElements output9 fitness_population9 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

    ;(princ "Initially positive solution are ") (princ count)(princ "\n")
  
  	;Calculate Average Fitness
  	(setq average_fitness0 (/ sum0 (length fitness_population0)))
        (setq average_fitness1 (/ sum1 (length fitness_population1)))
        (setq average_fitness2 (/ sum2 (length fitness_population2)))
        (setq average_fitness3 (/ sum3 (length fitness_population3)))
        (setq average_fitness4 (/ sum4 (length fitness_population4)))
        (setq average_fitness5 (/ sum5 (length fitness_population5)))
        (setq average_fitness6 (/ sum6 (length fitness_population6)))
        (setq average_fitness7 (/ sum7 (length fitness_population7)))
        (setq average_fitness8 (/ sum8 (length fitness_population8)))
        (setq average_fitness9 (/ sum9 (length fitness_population9)))
  	
  
  (setq initial_avg (apply 'max (list average_fitness0 average_fitness1 average_fitness2 average_fitness3 average_fitness4 average_fitness5 average_fitness6 average_fitness7 average_fitness8 average_fitness9)))
  ;(setq initial_avg (/ initi (length finalpopulation)))
    ;(princ "Average fitness ok\n")
 
  	
  (setq mig_iterator 0)
(while (< mig_iterator 15) 
         (setq final_popu nil)
  (setq newpop1 nil)
  (setq final_popu (list output0 output1 output2 output3 output4 output5 output6 output7 output8 output9))
 
  	(setq final_population nil)
  ;*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************
;(princ final_popu) 
  (princ mig_iterator)
  (princ "\n")
  (setq newpop1 (migration final_popu))
  ;(princ newpop1)

  
 ;(princ "\n")(princ group0)
  ;(princ "\n")(princ group1)
;(princ "\n")(princ group2)
;(princ "\n")(princ group3)
;(princ "\n")(princ group4)
;(princ "\n")(princ group5)
;(princ "\n")(princ group6)
;(princ "\n")(princ group7)
;(princ "\n")(princ group8)
;(princ "\n")(princ group9)
;/
  ;(setq final_pop12 (list group0 group1 group2 group3 group4 group5 group6 group7 group8 group9))
  ;(setq final_pop123 final_pop12)
  ;(newGA1 final_pop123)
;(princ final_pop12)


;(defun replace-n1 (new n lst / )
 ; (mapcar '(lambda (a) (if (= (setq n (1- n)) -1) new a)) lst)
  
  ;this module is used to create random chromosomes


    
  ;(princ final_popu)
         
  ; Final GA PROGRAM
;(setq initial_population (numberofchromosomes 300 16))


;(defun unique ( l )
 ; (if l
  ;  (cons (car l)
   ;   (unique (vl-remove (car l) (cdr l)))
    ;)
  ;)
;)

;(defun newGA()

	(setq fitness_population0 nil)
  (setq fitness_population1 nil)
(setq fitness_population2 nil)
(setq fitness_population3 nil)
(setq fitness_population4 nil)
(setq fitness_population5 nil)
(setq fitness_population6 nil)
(setq fitness_population7 nil)
(setq fitness_population8 nil)
(setq fitness_population9 nil)
  (setq fitness_population nil)

  	(setq new_population nil)
;	(setq maximum_iterations 20)
	(setq average_fitness nil)
	(setq crossover_probability 0.95)
	(setq mutation_probability 0.05)
    
      
	     (setq output0 nil)
  (setq output1 nil)
(setq output2 nil)
(setq output3 nil)
(setq output4 nil)
(setq output5 nil)
(setq output6 nil)
(setq output7 nil)
(setq output8 nil)
(setq output9 nil)
  

  	(setq finalpopulation newpop1)
               

    (princ "Initial_pop ok with length") (princ (length finalpopulation)) (princ "\n")
  
	     (setq output0 (append output0 (nth 0 finalpopulation)))
	   
	     (setq output1 (append output1 (nth 1 finalpopulation)))
	   
	     (setq output2 (append output2(nth 2 finalpopulation)))
	    
	     (setq output3 (append output3 (nth 3 finalpopulation)))
	   
	     (setq output4 (append output4 (nth 4 finalpopulation)))
	    
	     (setq output5(append output5 (nth 5 finalpopulation)))
	     
	     (setq output6(append output6 (nth  6 finalpopulation)))
	     
	     (setq output7 (append output7 (nth 7 finalpopulation)))
	     
	     (setq output8 (append output8 (nth 8 finalpopulation)))
	     
	     (setq output9 (append output9 (nth 9 finalpopulation)))
	      
            ;(princ (length output0))
  
	   ;  (princ output1)(princ "\n")
	    ; (princ output2)(princ "\n")
             ;(princ output3)(princ "\n")
	     ;(princ output4)(princ "\n")
	     ;(princ output5)(princ "\n")
	     ;(princ output6)(princ "\n")
	     ;(princ output7)(princ "\n")
	     ;(princ output8)(princ "\n")
	      ;(princ (length output0))
  
  	; Apply Fitness Function
  	(setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
    ;(setq count 0)
  	(foreach chromosome output0
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population0 (append fitness_population0 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output1
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population1 (append fitness_population1 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output2
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population2 (append fitness_population2 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  );(princ (length fitness_population2))
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output3
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population3 (append fitness_population3 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  );
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output4
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population4 (append fitness_population4 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output5
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population5 (append fitness_population5 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output6
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population6 (append fitness_population6 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output7
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population7 (append fitness_population7 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output8
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population8 (append fitness_population8 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  )
  (setq sum 0)
        (setq chromosome nil)
        (setq value  nil)
  	(foreach chromosome output9
	  	(setq value (fitness_function chromosome))  ;calculating fitness value of each chromosome
	    ;(princ "value of fitness= ")(princ value)(princ "\n")

	    ;(if (> value 0)
        ;   (setq count (+ count 1))
		;)
	  
		(setq fitness_population9 (append fitness_population9 (list value)))   ;in fitness_population the fitness value of each chromosome is appended
	  	(setq sum (+ sum value))
	  );(princ (length fitness_population9))
  ;*****************************************************************migration over here and mating starts******************************************





      (setq iterator 0)
  	(setq chance 0)
  (while
	    (and
	      (< iterator maximum_iterations)
	      (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list0 nil
	      mating_population0 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list0 (stochasticUniversalSampling fitness_population0 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
      (setq value 0)
	(foreach value selection_index_list0
	  
	       (setq add_in_mating0 (list (nth value output0)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population0 (append mating_population0 add_in_mating0))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population0) (randnum))))
		    (setq index2 (fix (* (length mating_population0) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population0) (randnum))))
		      (setq index2 (fix (* (length mating_population0) (randnum))))
			)

			(setq parent1 (nth index1 mating_population0))
		    (setq parent2 (nth index2 mating_population0))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
 ;| (foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;
	 (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	;  (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
        ; )
	)

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output0 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population0 nil)
	  
  	(foreach chromosome output0
	  	(setq value (fitness_function chromosome))
		(setq fitness_population0 (append fitness_population0 (list value)))
		(setq sum (+ sum value))
	  )
(setq elit nil)
    (setq elit (selectTopElements output0 fitness_population0 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
    ;(princ (length fitness_population0))
   
  	;Calculate Average Fitness
    (setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output0))))
          (setq output0 (replace-n (nth i best_population) jth output0))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness0 (/ sum (length fitness_population0)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness0) (princ "\n")

	
	(setq previous_average_fitness0 average_fitness0)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness0 new_average_fitness0)


	  (if(= previous_average_fitness0 average_fitness0)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	) ; End of iterator while

  ;**************************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
  (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list1 nil
	      mating_population1 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list1 (stochasticUniversalSampling fitness_population1 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list1
	  
	       (setq add_in_mating1 (list (nth value output1)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population1 (append mating_population1 add_in_mating1))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population1) (randnum))))
		    (setq index2 (fix (* (length mating_population1) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population1) (randnum))))
		      (setq index2 (fix (* (length mating_population1) (randnum))))
			)

			(setq parent1 (nth index1 mating_population1))
		    (setq parent2 (nth index2 mating_population1))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
    (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	 ; (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
    
   ;| (foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;
    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output1 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population1 nil)
	  
  	(foreach chromosome output1
	  	(setq value (fitness_function chromosome))
		(setq fitness_population1 (append fitness_population1 (list value)))
		(setq sum (+ sum value))
	  )
    (setq elit nil)
    (setq elit (selectTopElements output1 fitness_population1 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

   ;(princ (length fitness_population1))
 
  	;Calculate Average Fitness
    (setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output1))))
          (setq output1 (replace-n (nth i best_population) jth output1))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness1 (/ sum (length fitness_population1)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness1) (princ "\n")

	
	(setq previous_average_fitness1 average_fitness1)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness1 new_average_fitness1)


	  (if(= previous_average_fitness1 average_fitness1)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	) ;end of iterator while

  ;******************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list2 nil
	      mating_population2 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list2 (stochasticUniversalSampling fitness_population2 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list2
	  
	       (setq add_in_mating2 (list (nth value output2)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population2 (append mating_population2 add_in_mating2))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population2) (randnum))))
		    (setq index2 (fix (* (length mating_population2) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population2) (randnum))))
		      (setq index2 (fix (* (length mating_population2) (randnum))))
			)

			(setq parent1 (nth index1 mating_population2))
		    (setq parent2 (nth index2 mating_population2))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
   (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	 ; (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	 ; (princ (length outpu2))
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population2 nil)
	 
  	(foreach chromosome generated_offsprings
	  	(setq value (fitness_function chromosome))
		(setq fitness_population2 (append fitness_population2 (list value)))
		(setq sum (+ sum value))
	  )
(setq elit nil)
    (setq elit (selectTopElements output2 fitness_population2 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
 ;(princ (length fitness_population2))
 	(setq output2 generated_offsprings)
	(princ (length output2))
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output2))))
          (setq output2 (replace-n (nth i best_population) jth output2))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness2 (/ sum (length fitness_population2)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness2) (princ "\n")

	
	(setq previous_average_fitness2 average_fitness2)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness2 new_average_fitness2)


	  (if(= previous_average_fitness2 average_fitness2)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)
  ;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list3 nil
	      mating_population3 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list3 (stochasticUniversalSampling fitness_population3 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list3
	  
	       (setq add_in_mating3 (list (nth value output3)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population3 (append mating_population3 add_in_mating3))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population3) (randnum))))
		    (setq index2 (fix (* (length mating_population3) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population3) (randnum))))
		      (setq index2 (fix (* (length mating_population3) (randnum))))
			)

			(setq parent1 (nth index1 mating_population3))
		    (setq parent2 (nth index2 mating_population3))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
   (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	  ;(if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
        ; )
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population



	(setq output3 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population3 nil)
	  
  	(foreach chromosome output3
	  	(setq value (fitness_function chromosome))
		(setq fitness_population3 (append fitness_population3 (list value)))
		(setq sum (+ sum value))
	  )
	(setq elit nil)
    (setq elit (selectTopElements output3 fitness_population3 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

 ;(princ (length fitness_population3))

  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output3))))
          (setq output3 (replace-n (nth i best_population) jth output3))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness3 (/ sum (length fitness_population3)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness3) (princ "\n")

	
	(setq previous_average_fitness3 average_fitness3)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness3 new_average_fitness3)


	  (if(= previous_average_fitness3 average_fitness3)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list4 nil
	      mating_population4 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list4 (stochasticUniversalSampling fitness_population4 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list4
	  
	       (setq add_in_mating4 (list (nth value output4)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population4 (append mating_population3 add_in_mating4))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population4) (randnum))))
		    (setq index2 (fix (* (length mating_population4) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population4) (randnum))))
		      (setq index2 (fix (* (length mating_population4) (randnum))))
			)

			(setq parent1 (nth index1 mating_population4))
		    (setq parent2 (nth index2 mating_population4))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
  (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	  ;(if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

;	(princ (length generated_offsprings))

	(setq output4 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population4 nil)
	  
  	(foreach chromosome output4
	  	(setq value (fitness_function chromosome))
		(setq fitness_population4 (append fitness_population4 (list value)))
		(setq sum (+ sum value))
	  )
	(setq elit nil)
    (setq elit (selectTopElements output4 fitness_population4 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

 ;(princ (length fitness_population4))
 
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output4))))
          (setq output4 (replace-n (nth i best_population) jth output4))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness4 (/ sum (length fitness_population4)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness4) (princ "\n")

	
	(setq previous_average_fitness4 average_fitness4)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness4 new_average_fitness4)


	  (if(= previous_average_fitness4 average_fitness4)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
  ;********************************************************************************************************************************
  ;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list5 nil
	      mating_population6 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list5 (stochasticUniversalSampling fitness_population5 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list5
	  
	       (setq add_in_mating5 (list (nth value output5)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population5 (append mating_population5 add_in_mating5))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population5) (randnum))))
		    (setq index2 (fix (* (length mating_population5) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population5) (randnum))))
		      (setq index2 (fix (* (length mating_population5) (randnum))))
			)

			(setq parent1 (nth index1 mating_population5))
		    (setq parent2 (nth index2 mating_population5))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
  (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	  ;(if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output5 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population5 nil)
	  
  	(foreach chromosome output5
	  	(setq value (fitness_function chromosome))
		(setq fitness_population5 (append fitness_population5 (list value)))
		(setq sum (+ sum value))
	  )
	(setq elit nil)
    (setq elit (selectTopElements output5 fitness_population5 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

 ;(princ (length fitness_population5))
 
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output5))))
          (setq output5 (replace-n (nth i best_population) jth output5))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness5 (/ sum (length fitness_population5)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness5) (princ "\n")

	
	(setq previous_average_fitness5 average_fitness5)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness5 new_average_fitness5)


	  (if(= previous_average_fitness5 average_fitness5)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
  ;********************************************************************************************************************************
  ;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list6 nil
	      mating_population6 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list6 (stochasticUniversalSampling fitness_population6 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list6
	  
	       (setq add_in_mating6 (list (nth value output6)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population6 (append mating_population6 add_in_mating6))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population6) (randnum))))
		    (setq index2 (fix (* (length mating_population6) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population6) (randnum))))
		      (setq index2 (fix (* (length mating_population6) (randnum))))
			)

			(setq parent1 (nth index1 mating_population6))
		    (setq parent2 (nth index2 mating_population6))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
  (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	;  (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;
	

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output6 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population6 nil)
	  
  	(foreach chromosome output6
	  	(setq value (fitness_function chromosome))
		(setq fitness_population6 (append fitness_population6 (list value)))
		(setq sum (+ sum value))
	  )
(setq elit nil)
    (setq elit (selectTopElements output6 fitness_population6 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
 ;(princ (length fitness_population6))
 
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output6))))
          (setq output6 (replace-n (nth i best_population) jth output6))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness6 (/ sum (length fitness_population6)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness6) (princ "\n")

	
	(setq previous_average_fitness6 average_fitness6)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness6 new_average_fitness6)


	  (if(= previous_average_fitness6 average_fitness6)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
  ;********************************************************************************************************************************

;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list7 nil
	      mating_population7 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list7 (stochasticUniversalSampling fitness_population7 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list7
	  
	       (setq add_in_mating7 (list (nth value output7)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population7 (append mating_population7 add_in_mating7))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population7) (randnum))))
		    (setq index2 (fix (* (length mating_population7) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population7) (randnum))))
		      (setq index2 (fix (* (length mating_population7) (randnum))))
			)

			(setq parent1 (nth index1 mating_population7))
		    (setq parent2 (nth index2 mating_population7))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
   (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	 ; (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
        ; )
	)
	;|(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;
	

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output7 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population7 nil)
	  
  	(foreach chromosome output7
	  	(setq value (fitness_function chromosome))
		(setq fitness_population7 (append fitness_population7 (list value)))
		(setq sum (+ sum value))
	  )
	(setq elit nil)
    (setq elit (selectTopElements output7 fitness_population7 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

; (princ (length fitness_population7))
 
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output7))))
          (setq output7 (replace-n (nth i best_population) jth output7))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness7 (/ sum (length fitness_population7)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness7) (princ "\n")

	
	(setq previous_average_fitness7 average_fitness7)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness7 new_average_fitness7)


	  (if(= previous_average_fitness7 average_fitness7)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
  ;********************************************************************************************************************************
  ;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list8 nil
	      mating_population8 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list8 (stochasticUniversalSampling fitness_population8 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list8
	  
	       (setq add_in_mating8 (list (nth value output8)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population8 (append mating_population8 add_in_mating8))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population8) (randnum))))
		    (setq index2 (fix (* (length mating_population8) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population8) (randnum))))
		      (setq index2 (fix (* (length mating_population8) (randnum))))
			)

			(setq parent1 (nth index1 mating_population8))
		    (setq parent2 (nth index2 mating_population8))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
   (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	 ; (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
         ;)
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

	

	(setq output8 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
  	(setq fitness_population8 nil)
	  
  	(foreach chromosome output8
	  	(setq value (fitness_function chromosome))
		(setq fitness_population8 (append fitness_population8 (list value)))
		(setq sum (+ sum value))
	  )
	(setq elit nil)
    (setq elit (selectTopElements output8 fitness_population8 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))

 ;(princ (length fitness_population8))

  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output8))))
          (setq output8 (replace-n (nth i best_population) jth output8))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness8 (/ sum (length fitness_population8)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness8) (princ "\n")

	
	(setq previous_average_fitness8 average_fitness8)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness8 new_average_fitness8)


	  (if(= previous_average_fitness8 average_fitness8)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; end of iterator while
  ;********************************************************************************************************************************
  
;*********************************************************************************************************************************************************************
	(setq iterator 0)
  	(setq chance 0)
  
      (while
	    (and
	      (< iterator maximum_iterations)
	     (< chance chanceit)
	    ) 
	 ;Selection of mating population
	  
  	(setq selection_index_list9 nil
	      mating_population9 nil
	      
              )

	;(princ "Initial_pop ok with length") (princ (length fitness_population)) (princ "\n")
	
	  
  	(setq selection_index_list9 (stochasticUniversalSampling fitness_population9 mating_iter)) ;find segment which corresponds to the pointer and the corresponding index to the list

      ; (princ "\n")(princ selection_index_list0)
       ; (princ "selection ")(princ selection_index_list)
    ;(princ "Selection Index List ok with length")(princ (length selection_index_list)) (princ "\n")
	;(setq count_select 0)
	(foreach value selection_index_list9
	  
	       (setq add_in_mating9 (list (nth value output9)))
            ;(if (> value 0)
             ; (setq count_select (+ count_select 1))
		    ;)
		   (setq mating_population9 (append mating_population9 add_in_mating9))
	)
    
    ;(princ "Mating pop ok with length ") (princ mating_population) (princ "\n")
	;(princ "positive solutions in mating population are ") (princ count_select)(princ "\n")

  	;;Choose Parents and Perform Crossover Operation
  	
  		;(princ iterator)(princ "\n")
		(setq i	0
		      parent1 nil
		      parent2 nil
		      temp_list	nil
		      generated_offsprings nil
		)

	 (while (< i population_length)

	        (setq index1 (fix (* (length mating_population9) (randnum))))
		    (setq index2 (fix (* (length mating_population9) (randnum))))
	   
				  
		    (while (= index1 index2)
			  
	          (setq index1 (fix (* (length mating_population9) (randnum))))
		      (setq index2 (fix (* (length mating_population9) (randnum))))
			)

			(setq parent1 (nth index1 mating_population9))
		    (setq parent2 (nth index2 mating_population9))

					 
            (setq rndn (randnum))
					
	        (if (< rndn crossover_probability)
			  (progn
				
			    ;(princ "Parent 1")(princ parent1)(princ "\n")
			    ;(princ "parent 2")(princ parent2)(princ "\n")
			  
		        (setq temp_list (crossover (list parent1 parent2)))   ;calling the crossover function
			  )
		    )
           
	

	       (if (= temp_list nil)
			 (progn

			    (setq generated_offsprings (append generated_offsprings (list parent1)))
			    (setq generated_offsprings (append generated_offsprings (list parent2)))
			 )
			 
			 (progn
		       (if  (or (member (list nil) (nth 0 temp_list)) (member nil (nth 0 temp_list)))
		       (progn
		       )
		       (progn
		
			       (setq generated_offsprings
			           (append generated_offsprings
				         (list (nth 0 temp_list))
			           )
			       )
		       )
		       )
	
		      (if (or (member (list nil) (nth 1 temp_list)) (member nil (nth 1 temp_list)))
		      (progn
		      )
		      (progn
			
			  (setq generated_offsprings
			       (append generated_offsprings
				       (list (nth 1 temp_list))
			       )
			   )

			   )
			  )
			 )
		    )
		   
		  (setq i (+ i 1))
		)
    	
   ;(princ "after crossover\n")
	  
	  ; Mutation Probability on GENERATED OFFSPRINGS
   (setq offsprings nil)
	  ; Mutation Probability on GENERATED OFFSPRINGS
  	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq offsprings(append offsprings(list  (mutation chromosome))))
		  )
	        (progn
		  (setq offsprings(append offsprings (list chromosome)))
		  )
	    )
	 ; (if(< rndn mutation_probability)
	(setq generated_offsprings offsprings)
        ; )
	)
;|	(foreach chromosome generated_offsprings
	  (setq rndn (randnum))
	  (if(< rndn mutation_probability)
		(progn
		    (setq chromosome (mutation chromosome))
		  )
	    )
	)|;

    
  

  	;|fitness check
   	(foreach chromosome generated_offsprings
		(setq value (fitness_function chromosome))
	  	(if (< value average_fitness)
			(setq generated_offsprings (vl-remove chromosome generated_offsprings))
		)
	) |;
	
  	; Make new population

;	(princ generated_offsprings)

	(setq output9 generated_offsprings)
	  
	;(princ "Length of generated offspring is ")(princ (length final_population))(princ "\n")
    	
    
	
  	; Apply Fitness Function
  	
	;(setq fitness_population nil)

  	;(foreach chromosome final_population

	;  (setq value (fitness_function chromosome))
	 ; (setq fitness_population (append fitness_population (list value)))
	  
	  
	;)
	;(setq final_population temp_pop)

  	
  
	; Apply Fitness Function to new population
	(setq sum 0)
        (setq fitness_population9 nil)
  	(setq fitness_pop9 nil)
	  
  	(foreach chromosome output9
	  	(setq value (fitness_function chromosome));(princ value)
		(setq fitness_pop9 (append fitness_pop9 (list value)))
		(setq sum (+ sum value))
	  )
	 (setq fitness_population9 fitness_pop9)
        ; (princ (length fitness_population9))
	(setq elit nil)
    (setq elit (selectTopElements output9 fitness_population9 no_ele best_population fitness_pop))
    (setq best_population (nth 0 elit))
    (setq fitness_pop (nth 1 elit))
  	;Calculate Average Fitness
	(setq i 0)
        (setq jth 0)
       (while (< i no_ele)
	  (setq jth (fix (* (randnum) (length output9))))
          (setq output9 (replace-n (nth i best_population) jth output9))

         (setq i (+ i 1))
	)
  	(setq new_average_fitness9 (/ sum (length fitness_pop9)))

	(princ "Average fitness on iteration ") (princ iterator) (princ "  ") (princ new_average_fitness9) (princ "\n")

	
	(setq previous_average_fitness9 average_fitness9)
	  
	;(setq final_population new_population)
	  
	 (setq iterator (+ iterator 1))
	  
	 (setq average_fitness9 new_average_fitness9)


	  (if(= previous_average_fitness9 average_fitness9)
	    	(setq chance (+ chance 1))
		(setq chance 0)
	    )
    	 
	)  ; End of iterator while
      
    (setq mig_iterator (+ mig_iterator 1))
  )

  (setq average_fitness (apply 'max(list average_fitness0 average_fitness1 average_fitness2 average_fitness3 average_fitness4 average_fitness5 average_fitness6 average_fitness7 average_fitness8 average_fitness9)))
;(setq average_fitness (/ average_f (length finalpopulation)))
   ; (setq unique_fitness0 (unique fitness_population0))
    ;(setq unique_fitness1 (unique fitness_population1))
;(setq unique_fitness2 (unique fitness_population2))
;(setq unique_fitness3 (unique fitness_population3))
;(setq unique_fitness4 (unique fitness_population4))
;(setq unique_fitness5 (unique fitness_population5))
;(setq unique_fitness6 (unique fitness_population6))
;(setq unique_fitness7 (unique fitness_population7))
;(setq unique_fitness8 (unique fitness_population8))
;(setq unique_fitness9 (unique fitness_population9))

  (setq unique_fit nil)
  (setq overall nil)
  (setq overall (list output0 output1 output2 output3 output4 output5 output6 output7 output8 output9))
  (setq unique_fit (list fitness_population0 fitness_population1 fitness_population2 fitness_population3 fitness_population4 fitness_population5 fitness_population6 fitness_population7 fitness_population8 fitness_population9))
 ;problem/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
  ;(setq unique_fitness (apply 'max (unique_fitness0 unique_fitness1 unique_fitness2 unique_fitness3 unique_fitness4 unique_fitness5 unique_fitness6 unique_fitness7 unique_fitness8 unique_fitness9)))
  
  (setq i 0)
  (setq j 0)
  (setq len nil)
  (setq uniquefit nil)
  (while (< i (length unique_fit))
           (setq len (nth i unique_fit))
            (while (< j (length len))
	          ; (setq tempp (nth i unique_fit))
	          ;(setq lis (cons (list space_x (+ space_y space_hgt)) lis))
                  (setq uniquefit (cons  (nth j len) uniquefit))
                  (setq j (+ j 1))

	      )
             (setq i (+ i 1))
    )
  
  
  
  
  
  ;(princ (length uniquefit))
  (setq unique_fitness nil)
  (setq unique_fitness (unique uniquefit))
	(princ "Unique Fitness Population ") (princ (length unique_fitness)) (princ "\n") 
(setq finalp nil)
  (setq uniquefit1 nil)
  (setq len1 nil)
(setq finalp (list output0 output1 output2 output3 output4 output5 output6 output7 output8 output9))
  (setq i 0)
  (setq j 0)
  (while (< i (length finalp))
           (setq len1 (nth i finalp))
            (while (< j (length len1))
	          ; (setq tempp (nth i unique_fit))
                  ;(setq uniquefit1 (append uniquefit1 (list (nth j len1))))
	          (setq uniquefit1 (cons  (nth j len1) uniquefit1))
                  (setq j (+ j 1))

	      )
             (setq i (+ i 1))
    )
 
  (setq max_chro (apply 'max fitness_pop))
    
  (setq ind (vl-position max_chro fitness_pop))
  (setq best_chro (nth ind best_population))
  ;|	(setq index 0)
  
	(while (< index 10)
     
	   (setq topElements
		  (append topElements
	 		(list (nth index uniquefit1))
		   )
		)

	   ;(princ (list (nth index final_population)))
	   ;(princ "\n")
	   
	   (setq index (1+ index))
	)   |;


    ;(princ iterator)(princ "\n")
  (princ uniquefit1)(princ "\n")
  (princ uniquefit)(princ "\n")
  	(princ initial_avg)(princ "\n")
  	(princ average_fitness)(princ "\n")
   (princ max_chro)(princ "\n")
   best_chro
    ;(princ fitness_population)(princ)

    
    

    ;returns the top elements
;(setq topElements (nth 0 uniquefit1))
;  (princ topElements)
 ;  topElements
  
  ) ;end of newGA
