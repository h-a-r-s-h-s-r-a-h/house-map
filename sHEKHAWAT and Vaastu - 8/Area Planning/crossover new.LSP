;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Function for OX Cross-Over Operator

(defun crossover (parents / listAllElements firstParent secondParent firstCut secondCut temp firstChild secondChild i output)
  ; (setq listAllElements (list 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15))
  (setq firstParent  (nth 0 (nth 0 parents)))
  (setq firstParentW (nth 1 (nth 0 parents)))
  (setq firstParentH (nth 2 (nth 0 parents)))
  (setq secondParent  (nth 0 (nth 1 parents)))
  (setq secondParentW (nth 1 (nth 1 parents)))
  (setq secondParentH (nth 2 (nth 1 parents)))
;(princ firstParent)
  (setq firstCut 0)
  (setq secondCut 0)

  (while
    (= firstCut secondCut)
    (setq firstCut (randomFromRange 1 (- (length firstParent) 1)))
    (setq secondCut (randomFromRange 1 (- (length firstParent) 1)))
    )

  (if
    (< secondCut firstCut)
    (progn
      (setq temp secondCut)
      (setq secondCut firstCut)
      (setq firstCut temp)
      )
    )
  (setq firstChild nil)
  (setq secondChild nil)
  (setq firstChildW nil)
  (setq firstChildH nil)
  (setq secondChildW nil)
  (setq secondChildH nil)
  ;(princ firstCut) (princ secondCut)
  (setq i 0)
  (while
    (< i (length firstParent))
    (if
      (or
	(< i firstCut)
	(>= i secondCut)
	  )

      (progn
	(setq firstChild  (append firstChild  (list (nth i firstParent))))
	(setq firstChildW (append firstChildW (list (nth i firstParentW))))
	(setq firstChildH (append firstChildH (list (nth i firstParentH))))
	(setq secondChild  (append secondChild  (list (nth i secondParent))))
	(setq secondChildW (append secondChildW (list (nth i secondParentW))))
	(setq secondChildH (append secondChildH (list (nth i secondParentH))))
	)

      (progn
	(setq firstChild (append firstChild (list (nth i secondParent))))
	(setq firstChildW (append firstChildW (list (nth i secondParentW))))
	(setq firstChildH (append firstChildH (list (nth i secondParentH))))
        (setq secondChild (append secondChild (list (nth i firstParent))))
	(setq secondChildW (append secondChildW (list (nth i firstParentW))))
	(setq secondChildH (append secondChildH (list (nth i firstParentH))))
	)
      )

    (setq i (+ i 1))
    )

  (setq firstChild  (slidingMotion firstChild secondChild firstParent secondParent firstChildW secondChildW firstParentW secondParentW firstChildH secondChildH firstParentH secondParentH firstCut secondCut))
  (setq secondChild (slidingMotion  secondChild firstChild  secondParent firstParent secondChildW firstChildW  secondParentW firstParentW secondChildH firstChildH  secondParentH firstParentH firstCut secondCut))
  (setq output (list firstChild secondChild))
  output
  ;(princ "\n")(princ output)
  ;(kk k)
  )

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Function for generating random number within a range
(defun randomFromRange (start end)
  (fix (+ start (* (randnum) end)))
  )

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Generate a Random Number
(defun randnum (/ modulus multiplier increment random)

  (if (not seed)
    (setq seed (getvar "DATE"))
    )

  (setq modulus    65536
	multiplier 25173
	increment  13849
	seed  (rem (+ (* multiplier seed) increment) modulus)
	random     (/ seed modulus)
	)
  )
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Sliding Motion for Duplicate elements in a off-spring
(defun slidingMotion (firstCh secondCh firstParent secondParent firstChW secondChW firstParentW secondParentW firstChH secondChH firstParentH secondParentH first second / foffSpring)
   (setq p 0)
   (if (and (= first 1)(= second 3))
     (progn
           (setq p 1)
     )
     (progn
        (if (and (= first 1)(= second 2))
          (progn
               (setq p 2)
            )
	   (progn
	      (if (and (= first 2)(= second 3))
                    (progn
                        (setq p 3)
                    )
		)
	     )
	  )
       )
     )
 ; (princ p)
     (setq first_gene nil)
  (setq first_geneW nil)
  (setq first_geneH nil)
  (setq second_gene nil)
  (setq second_geneW nil)
  (setq second_geneH nil)
  (setq first_gene1 nil)
  (setq first_gene2 nil)
  (setq first_gene3 nil)
  (setq first_gene1W nil)
  (setq first_gene2W nil)
  (setq first_gene3W nil)
  (setq first_gene1H nil)
  (setq first_gene2H nil)
  (setq first_gene3H nil)
  (setq second_gene1 nil)
  (setq second_gene2 nil)
  (setq second_gene3 nil)
  (setq second_gene1W nil)
  (setq second_gene2W nil)
  (setq second_gene3W nil)
  (setq second_gene1H nil)
  (setq second_gene2H nil)
  (setq second_gene3H nil)
  (setq third_gene nil)
  (setq third_gene1 nil)
  (setq third_gene2 nil)
  (setq third_gene3 nil)
  (setq third_geneW nil)
  (setq third_gene1W nil)
  (setq third_gene2W nil)
  (setq third_gene3W nil)
  (setq third_geneH nil)
  (setq third_gene1H nil)
  (setq third_gene2H nil)
  (setq third_gene3H nil)
  (setq fourth_gene nil)
  (setq fourth_geneW nil)
  (setq fourth_geneH nil)
  (setq fourth_gene2 nil)
  (setq fourth_gene2W nil)
  (setq fourth_gene2H nil)
  (setq offSpring nil)
  (setq offSpringW nil)
  (setq oofSpringH nil)
  (setq ele1 0)
  (setq ele2 0)
  (setq ele1W 0)
  (setq ele2W 0)
  (setq ele1H 0)
  (setq ele2H 0)
  
     (if (or (= p 1)(= p 2))
       (progn
          (setq first_gene (nth 0 firstParent))
	 (setq first_geneW (nth 0 firstParentW))
	 (setq first_geneH (nth 0 firstParentH))
          (setq ele1 (nth 0 first_gene))
         ; (setq ele2 (nth 1 first_gene))
          (setq second_gene (nth 1 secondParent))
	 (setq ci 0)
	 (setq i 0)
	  (while (< i (length first_gene))
		    (if (= ele1 (nth i second_gene))
		      (setq ci (+ ci 1))
		      )
		    (setq i (+ i 1))
		    )
	; (princ ai)
           (if (= ci 1)
	     (progn
	     (setq third_gene (nth 0 secondParent))
	     (setq third_geneW (nth 0 secondParentW))
	     (setq third_geneH (nth 0 secondParentH))
	     (setq ele1 (nth 0 third_gene))
	    ;  (setq ele2 (nth 1 third_gene))
	      (setq ele1W (nth 0 third_geneW))
	      ;(setq ele2W (nth 1 third_geneW))
	      (setq ele1H (nth 0 third_geneH))
	     ; (setq ele2H (nth 1 third_geneH))
	      (setq fourth_gene (nth 1 firstCh))
	     (setq fourth_geneW (nth 1 firstChW))
	     (setq fourth_geneH (nth 1 firstChH))
	      (setq fourth_gene (replace-n ele1 1 fourth_gene))
	    ; (setq fourth_gene (replace-n ele2 3 fourth_gene))
	      (setq fourth_geneW (replace-n ele1W 1 fourth_geneW))
	   ;  (setq fourth_geneW (replace-n ele2W 3 fourth_geneW))
	      (setq fourth_geneH (replace-n ele1H 1 fourth_geneH))
	     ;(setq fourth_geneH (replace-n ele2H 3 fourth_geneH))
	     )
	   
	     )
          (setq first_gene1 (nth 0 firstParent))
	 (setq first_gene1W (nth 0 firstParentW))
	 (setq first_gene1H (nth 0 firstParentH))
          (setq ele1 (nth 1 first_gene1))
        ;  (setq ele2 (nth 3 first_gene1))
          (setq second_gene1 (nth 1 secondParent))
	  (setq di 0)
	 (setq i 0)
	  (while (< i (length first_gene1))
		    (if  (= ele1 (nth i second_gene1))
		      (setq di (+ di 1))
		      )
		    (setq i (+ i 1))
		    )
	 ;(princ ai)
           (if (= di 1)
	     (progn
	     (setq third_gene1 (nth 0 secondParent))
	     (setq third_gene1W (nth 0 secondParentW))
	     (setq third_gene1H (nth 0 secondParentH))
	     (setq ele1 (nth 1 third_gene1))
	    ;  (setq ele2 (nth 3 third_gene1))
	     (setq ele1W (nth 1 third_gene1W))
	     ; (setq ele2W (nth 3 third_gene1W))
	     (setq ele1H (nth 1 third_gene1H))
	    ;  (setq ele2H (nth 3 third_gene1H))
	      (setq fourth_gene (nth 1 firstCh))
	     (setq fourth_geneW (nth 1 firstChW))
	     (setq fourth_geneH (nth 1 firstChH))
	      (setq fourth_gene (replace-n ele1 0 fourth_gene))
	     ;(setq fourth_gene (replace-n ele2 1 fourth_gene))
	     (setq fourth_geneW (replace-n ele1W 0 fourth_geneW))
	    ; (setq fourth_geneW (replace-n ele2W 1 fourth_geneW))
	     (setq fourth_geneH (replace-n ele1H 0 fourth_geneH))
	    ; (setq fourth_geneH (replace-n ele2H 1 fourth_geneH))
	     )
	    
	     )
	 (if (and (= ci 0) (= di 0))
	   (progn
	        (setq fourth_gene (nth 1 secondParent))
	        (setq fourth_geneW (nth 1 secondParentW))
	        (setq fourth_geneH (nth 1 secondParentH))
	     )
	   )
	 (if (and (= ci 1) (= di 1))
	   (progn
	        (setq fourth_gene (list (nth 1 third_gene1)(nth 0 third_gene)))
	        (setq fourth_geneW (list (nth 1 third_gene1W) (nth 0 third_geneW)))
	        (setq fourth_geneH (list (nth 1 third_gene1H) (nth 0 third_geneH)))   
	     )
	   )
	   
	 )
       )
       (if (or (= p 1)(= p 3))
       (progn
          (setq first_gene2 (nth 3 firstParent))
	 (setq first_gene2W (nth 3 firstParentW))
	 (setq first_gene2H (nth 3 firstParentH))
          (setq ele1 (nth 0 first_gene2))
         ; (setq ele2 (nth 1 first_gene2))
          (setq second_gene2 (nth 2 secondParent))
	 (setq i 0)
	 (setq ai 0)
	  (while (< i (length first_gene2))
		    (if  (= ele1 (nth i second_gene2))
		      (setq ai (+ ai 1))
		      )
		    (setq i (+ i 1))
		    )
	   ;(princ ai)
           (if (= ai 1)
	     (progn
	     (setq third_gene2 (nth 3 secondParent))
	     (setq third_gene2W (nth 3 secondParentW))
	     (setq third_gene2H (nth 3 secondParentH))
	     (setq ele1 (nth 0 third_gene2))
	     ; (setq ele2 (nth 1 third_gene2))
	     (setq ele1W (nth 0 third_gene2W))
	     ; (setq ele2W (nth 1 third_gene2W))
	     (setq ele1H (nth 0 third_gene2H))
	     ; (setq ele2H (nth 1 third_gene2H))
	      (setq fourth_gene2 (nth 2 firstCh))
	     (setq fourth_gene2W (nth 2 firstChW))
	     (setq fourth_gene2H (nth 2 firstChH))
	      (setq fourth_gene2 (replace-n ele1 1 fourth_gene2))
	    ; (setq fourth_gene2 (replace-n ele2 3 fourth_gene2));(princ fourth_gene2)
	      (setq fourth_gene2W (replace-n ele1W 1 fourth_gene2W))
	    ; (setq fourth_gene2W (replace-n ele2W 3 fourth_gene2W))
	      (setq fourth_gene2H (replace-n ele1H 1 fourth_gene2H))
	    ; (setq fourth_gene2H (replace-n ele2H 3 fourth_gene2H))
	     )
	    
	     )
          (setq first_gene3 (nth 3 firstParent))
	 (setq first_gene3W (nth 3 firstParentW))
	 (setq first_gene3H (nth 3 firstParentH))
          (setq ele1 (nth 1 first_gene3))
         ; (setq ele2 (nth 3 first_gene3))
          (setq second_gene3 (nth 2 secondParent))
	  (setq bi 0)
	  (setq i 0)
	  (while (< i (length first_gene3))
		    (if  (= ele1 (nth i second_gene3))
		      (setq bi (+ bi 1))
		      )
		    (setq i (+ i 1))
		    )
	 ;(princ ai)
           (if (= bi 1)
	     (progn
	     (setq third_gene3 (nth 3 secondParent))
	     (setq third_gene3W (nth 3 secondParentW))
	     (setq third_gene3H (nth 3 secondParentH))
	     (setq ele1 (nth 1 third_gene3))
	     ; (setq ele2 (nth 3 third_gene3))
	     (setq ele1W (nth 1 third_gene3W))
	     ; (setq ele2W (nth 3 third_gene3W))
	     (setq ele1H (nth 1 third_gene3H))
	     ; (setq ele2H (nth 3 third_gene3H))
	      (setq fourth_gene2 (nth 2 firstCh))
	     (setq fourth_gene2W (nth 2 firstChW))
	     (setq fourth_gene2H (nth 2 firstChH))
	     (setq fourth_gene2 (replace-n ele1 0 fourth_gene2))
	     ;(setq fourth_gene2 (replace-n ele2 1 fourth_gene2))
	     (setq fourth_gene2W (replace-n ele1W 0 fourth_gene2W))
	    ; (setq fourth_gene2W (replace-n ele2W 1 fourth_gene2W))
	     (setq fourth_gene2H (replace-n ele1H 0 fourth_gene2H))
	    ; (setq fourth_gene2H (replace-n ele2H 1 fourth_gene2H))
	          )
	     )
	 (if (and (= ai 0) (= bi 0))
	   (progn
	        (setq fourth_gene2 (nth 2 secondParent))
	        (setq fourth_gene2W (nth 2 secondParentW))
	        (setq fourth_gene2H (nth 2 secondParentH))
	     )
	   )
	 (if (and (= ai 1) (= bi 1))
	   (progn
	         (setq fourth_gene2 (list (nth 1 third_gene3) (nth 0 third_gene2)))
	        (setq fourth_gene2W (list (nth 1 third_gene3W) (nth 0 third_gene2W)))
	        (setq fourth_gene2H (list (nth 1 third_gene3H) (nth 0 third_gene2H))) 
	     )
	   )
	     
	 )
	 )
 (if (= p 2)
   (progn
   (setq offSpring (list first_gene fourth_gene (nth 2 firstParent) (nth 3 firstParent)))
   (setq offSpringW (list first_geneW fourth_geneW (nth 2 firstParentW) (nth 3 firstParentW)))
   (setq offSpringH (list first_geneH fourth_geneH (nth 2 firstParentH) (nth 3 firstParentH)))
    )
    )
  
   (if (= p 3)
   (progn
   (setq offSpring (list (nth 0 firstParent) (nth 1 firstParent)  fourth_gene2 first_gene2))
   (setq offSpringW (list (nth 0 firstParentW) (nth 1 firstParentW)  fourth_gene2W first_gene2W))
   (setq offSpringH (list (nth 0 firstParentH) (nth 1 firstParentH)  fourth_gene2H first_gene2H))
     )
     )
   
    (if (= p 1)
      (progn
   (setq offSpring (list first_gene fourth_gene  fourth_gene2 first_gene2))
   (setq offSpringW (list first_geneW fourth_geneW  fourth_gene2W first_gene2W))
   (setq offSpringH (list first_geneH fourth_geneH  fourth_gene2H first_gene2H))
      )
    )
  
   
  ;(princ offSpring)
    (setq foffSpring (list offSpring offSpringW offSpringH))
	  
  )

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------


;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Find Maximum Adjacency of an element with another element
(defun maximumAdjacencyWithElement (adjacentElement / arr maxElement index pos answer)
  (setq arr (matrix))
    ;| '(
		   (0 8 6 6 4 6 7 6 4 5 3 2 2 2 8 6)
		   (8 0 6 10 8 6 7 6 4 5 3 2 2 2 8 6)
		   (6 6 0 8 6 8 8 9 4 4 3 6 6 4 4 6)
		   (6 10 8 0 6 8 6 9 4 4 3 4 4 4 4 6)
		   (4 8 6 6 0 10 5 5 2 2 8 2 2 2 4 2)
		   (6 6 8 8 10 0 8 7 6 2 9 5 2 2 4 2)
		   (7 7 8 6 5  8 0 10 10 8 2 2 2 2 4 2)
		   (6 6 9 9 5 7 10 0 6 6 4 4 4 4 4 6)
		   (4 4 4 4 2 6 10 6 0 8 6 6 6 6 6 9)
		   (5 5 4 4 2 2 8 6 8 0 10 4 4 4 6 4)
		   (3 3 3 3 8 9 2 4 6 10 0 2 2 2 4 4)
		   (2 2 6 4 2 5 2 4 6 4 2 0 8 10 2 9)
		   (2 2 6 4 2 2 2 4 6 4 2 8 0 10 2 9)
		   (2 2 4 4 2 2 2 4 6 4 2 10 10 0 2 4)
		   (8 8 4 4 4 4 4 4 6 6 4 2 2 2 0 6)
		   (6 6 6 6 2 2 2 6 9 4 4 9 9 4 6 0)
		  )
 )|;
  (setq maxElement (apply 'max (nth adjacentElement arr)))
  (setq index 0)
  (setq pos 0)
  (foreach element (nth adjacentElement arr)
    (if
      (= maxElement element)
      (setq pos index)
      )
    (setq index (+ index 1))
    )
  (setq answer pos)
  )

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------
;Replace an element in list
(defun replace-n (new n lst / )
  (mapcar '(lambda (a) (if (= (setq n (1- n)) -1) new a)) lst)
  )

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------